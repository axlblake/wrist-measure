<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Hand Measurement Wizard</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f4f6f9;
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }
    #app {
      width: 820px;
      background: white;
      border-radius: 10px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
      padding: 20px 40px;
    }
    h2 { text-align: center; margin-bottom: 20px; }
    .step { display: none; }
    .active { display: block; }
    .nav { text-align: center; margin-top: 20px; }
    button {
      padding: 10px 20px;
      margin: 5px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
    }
    button.primary { background: #007bff; color: white; }
    button.secondary { background: #6c757d; color: white; }
    canvas, video { border: 1px solid #ccc; }
    pre {
      background: #f1f1f1;
      padding: 10px;
      border-radius: 5px;
      overflow-x: auto;
      max-height: 300px;
    }
    .video-container {
      position: relative;
      width: 640px;
      height: 480px;
      margin: 0 auto;
    }
    .video-container video,
    .video-container canvas {
      position: absolute;
      top: 0;
      left: 0;
    }
    #overlay { pointer-events: none; }
  </style>
</head>
<body>
<div id="app">
  <h2>Hand Measurement Wizard</h2>

  <!-- Step 1 -->
  <div class="step active" id="step1">
    <p>Welcome! This wizard will measure your hand and fingers for parametric modeling.</p>
    <ol>
      <li>Place your <b>hand flat</b> in front of the camera (palm up or down).</li>
      <li>Ensure a <b>reference object</b> (like a credit card) is visible in the same frame.</li>
      <li>Good lighting and flat angle will improve accuracy.</li>
    </ol>
    <div class="nav">
      <button class="primary" onclick="nextStep(2)">Start</button>
    </div>
  </div>

  <!-- Step 2 -->
  <div class="step" id="step2">
    <p>Align your hand with the overlay and make sure the card is inside the rectangle. Click <b>Capture</b> when ready.</p>
    <div class="video-container">
      <video id="video" autoplay muted playsinline width="640" height="480"></video>
      <canvas id="skeleton" width="640" height="480"></canvas>
      <canvas id="overlay" width="640" height="480"></canvas>
    </div>
    <div class="nav">
      <button class="secondary" onclick="nextStep(1)">Back</button>
      <button class="primary" onclick="nextStep(3)">Capture</button>
    </div>
  </div>

  <!-- Step 3 -->
  <div class="step" id="step3">
    <p>Click on two points of your reference object (e.g. left and right edge of the card).</p>
    <canvas id="calibrationCanvas" width="640" height="480"></canvas>
    <div class="nav">
      <button class="secondary" onclick="nextStep(2)">Back</button>
      <button class="primary" onclick="finishCalibration()">Done</button>
    </div>
  </div>

  <!-- Step 4 -->
  <div class="step" id="step4">
    <p>Here are your measurements:</p>
    <pre id="markdown"></pre>
    <div class="nav">
      <button class="secondary" onclick="nextStep(3)">Back</button>
      <button class="primary" onclick="downloadFile('hand_measurements.md','md')">Download MD</button>
      <button class="primary" onclick="downloadFile('hand_measurements.csv','csv')">Download CSV</button>
    </div>
  </div>
</div>

<script>
  const video=document.getElementById("video");
  const skeleton=document.getElementById("skeleton");
  const skeletonCtx=skeleton.getContext("2d");
  const overlay=document.getElementById("overlay");
  const overlayCtx=overlay.getContext("2d");
  const calibrationCanvas=document.getElementById("calibrationCanvas");
  const calibCtx=calibrationCanvas.getContext("2d");
  const mdBox=document.getElementById("markdown");

  let latestLandmarks=null;
  let calibrationPoints=[];
  let calibrationScale=100;
  const referenceRealLength=85.6; // mm (card width)
  let snapshot=null;

  // === Wizard navigation ===
  function nextStep(n){
    document.querySelectorAll('.step').forEach(s=>s.classList.remove('active'));
    document.getElementById('step'+n).classList.add('active');
    if(n===2) startCamera();
    if(n===3) showSnapshot();
    if(n===4) showMeasurements();
  }

  // === Distance ===
  function dist(a,b){ return Math.sqrt((a.x-b.x)**2+(a.y-b.y)**2+(a.z-b.z)**2); }

  // === Measurement calculation ===
  function calcMeasurements(landmarks){
    const fingers={Thumb:[1,2,3,4],Index:[5,6,7,8],Middle:[9,10,11,12],Ring:[13,14,15,16],Little:[17,18,19,20]};
    let result="# Hand Measurements (mm)\n\n"; let csv="Name,Length_mm\n";

    result+="## Finger lengths\n";
    for(let [name,ids] of Object.entries(fingers)){
      let len=0; for(let i=0;i<ids.length-1;i++) len+=dist(landmarks[ids[i]],landmarks[ids[i+1]]);
      let val=(len*calibrationScale).toFixed(1);
      result+=`- ${name}: ${val} mm\n`; csv+=`${name},${val}\n`;
    }

    result+="\n## Phalanges\n";
    for(let [name,ids] of Object.entries(fingers)){
      for(let i=0;i<ids.length-1;i++){
        let d=dist(landmarks[ids[i]],landmarks[ids[i+1]]);
        let val=(d*calibrationScale).toFixed(1);
        result+=`- ${name} P${i+1}: ${val} mm\n`; csv+=`${name} P${i+1},${val}\n`;
      }
    }

    result+="\n## Knuckles distances\n";
    const mcp=[5,9,13,17];
    for(let i=0;i<mcp.length-1;i++){
      let d=dist(landmarks[mcp[i]],landmarks[mcp[i+1]]);
      let val=(d*calibrationScale).toFixed(1);
      result+=`- MCP${i+1}â€“MCP${i+2}: ${val} mm\n`; csv+=`MCP${i+1}-${i+2},${val}\n`;
    }
    return {md:result,csv};
  }

  function showMeasurements(){ const {md}=calcMeasurements(latestLandmarks); mdBox.textContent=md; }
  function downloadFile(name,type){ const {md,csv}=calcMeasurements(latestLandmarks); let blob=new Blob([type==="md"?md:csv],{type:"text/plain"}); let a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download=name; a.click(); }

  // === Camera + Mediapipe ===
  async function startCamera(){
    try{
      const stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:"environment"}});
      video.srcObject=stream;
      video.play();
      requestAnimationFrame(processFrame);
      drawOverlay();
    }catch(err){ alert("Camera error: "+err); }
  }

  async function processFrame(){
    if(video.readyState===4){ await hands.send({image:video}); }
    requestAnimationFrame(processFrame);
  }

  // === Overlay guide ===
  function drawOverlay(){
    overlayCtx.clearRect(0,0,640,480);
    // Reference card rectangle
    overlayCtx.strokeStyle="rgba(255,0,0,0.7)";
    overlayCtx.lineWidth=3;
    overlayCtx.strokeRect(480,360,140,80);
    overlayCtx.fillStyle="rgba(255,0,0,0.1)";
    overlayCtx.fillRect(480,360,140,80);
    // Hand circle
    overlayCtx.beginPath();
    overlayCtx.arc(200,250,80,0,2*Math.PI);
    overlayCtx.strokeStyle="rgba(0,0,255,0.7)";
    overlayCtx.stroke();
    overlayCtx.fillStyle="rgba(0,0,255,0.1)";
    overlayCtx.fill();
  }

  // === Snapshot for calibration ===
  function showSnapshot(){
    calibCtx.drawImage(video,0,0,640,480);
  }

  calibrationCanvas.addEventListener("click",e=>{
    if(calibrationPoints.length<2){
      const rect=calibrationCanvas.getBoundingClientRect();
      calibrationPoints.push({x:(e.clientX-rect.left)/640,y:(e.clientY-rect.top)/480,z:0});
      calibCtx.fillStyle="red"; calibCtx.beginPath(); calibCtx.arc(e.clientX-rect.left,e.clientY-rect.top,5,0,2*Math.PI); calibCtx.fill();
    }
  });

  function finishCalibration(){
    if(calibrationPoints.length===2){
      let pxDist=dist(calibrationPoints[0],calibrationPoints[1]);
      calibrationScale=referenceRealLength/pxDist;
    }
    nextStep(4);
  }

  // === Mediapipe Hands ===
  const hands=new Hands({locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
  hands.setOptions({maxNumHands:1,minDetectionConfidence:0.7,minTrackingConfidence:0.7});
  hands.onResults(results=>{
    skeletonCtx.clearRect(0,0,640,480);
    if(results.multiHandLandmarks?.length>0){
      const lm=results.multiHandLandmarks[0];
      latestLandmarks=lm;
      drawConnectors(skeletonCtx,lm,HAND_CONNECTIONS,{color:'#0f0'});
      drawLandmarks(skeletonCtx,lm,{color:'#f00'});
    }
  });
</script>
</body>
</html>
