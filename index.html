<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Hand Measurement Wizard</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f4f6f9;
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }
    #app {
      width: 820px;
      background: white;
      border-radius: 10px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
      padding: 20px 40px;
    }
    h2 { text-align: center; margin-bottom: 20px; }
    .step { display: none; }
    .active { display: block; }
    .nav {
      text-align: center;
      margin-top: 20px;
    }
    button {
      padding: 10px 20px;
      margin: 5px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
    }
    button.primary { background: #007bff; color: white; }
    button.secondary { background: #6c757d; color: white; }
    canvas { border: 1px solid #ccc; margin-top: 10px; }
    pre {
      background: #f1f1f1;
      padding: 10px;
      border-radius: 5px;
      overflow-x: auto;
      max-height: 300px;
    }
    #overlay {
      position: absolute;
      top: 0; left: 0;
      pointer-events: none;
    }
    .video-container {
      position: relative;
      display: inline-block;
    }
  </style>
</head>
<body>
<div id="app">
  <h2>Hand Measurement Wizard</h2>

  <!-- Step 1 -->
  <div class="step active" id="step1">
    <p>Welcome! This wizard will measure your hand and fingers for parametric modeling.</p>
    <ol>
      <li>Place your <b>hand flat</b> in front of the camera (palm up or down).</li>
      <li>Ensure a <b>reference object</b> (like a credit card) is visible in the same frame.</li>
      <li>Good lighting and flat angle will improve accuracy.</li>
    </ol>
    <div class="nav">
      <button class="primary" onclick="nextStep(2)">Start</button>
    </div>
  </div>

  <!-- Step 2 -->
  <div class="step" id="step2">
    <p>Align your hand with the overlay and make sure the card is inside the rectangle. Click <b>Capture</b> when ready.</p>
    <div class="video-container">
      <video id="video" autoplay playsinline style="display:none"></video>
      <canvas id="output" width="640" height="480"></canvas>
      <canvas id="overlay" width="640" height="480"></canvas>
    </div>
    <div class="nav">
      <button class="secondary" onclick="nextStep(1)">Back</button>
      <button class="primary" onclick="nextStep(3)">Capture</button>
    </div>
  </div>

  <!-- Step 3 -->
  <div class="step" id="step3">
    <p>Click on two points of your reference object (e.g. left and right edge of the card).</p>
    <canvas id="calibrationCanvas" width="640" height="480"></canvas>
    <div class="nav">
      <button class="secondary" onclick="nextStep(2)">Back</button>
      <button class="primary" onclick="finishCalibration()">Done</button>
    </div>
  </div>

  <!-- Step 4 -->
  <div class="step" id="step4">
    <p>Here are your measurements:</p>
    <pre id="markdown"></pre>
    <div class="nav">
      <button class="secondary" onclick="nextStep(3)">Back</button>
      <button class="primary" onclick="downloadFile('hand_measurements.md','md')">Download MD</button>
      <button class="primary" onclick="downloadFile('hand_measurements.csv','csv')">Download CSV</button>
    </div>
  </div>
</div>

<script>
  const videoElement=document.getElementById('video');
  const canvasElement=document.getElementById('output');
  const canvasCtx=canvasElement.getContext('2d');
  const calibrationCanvas=document.getElementById('calibrationCanvas');
  const calibCtx=calibrationCanvas.getContext('2d');
  const mdBox=document.getElementById('markdown');
  const overlayCanvas=document.getElementById('overlay');
  const overlayCtx=overlayCanvas.getContext('2d');

  let latestLandmarks=null;
  let calibrationPoints=[];
  let calibrationScale=100;
  const referenceRealLength=85.6; // mm, card width
  let snapshot=null;

  // Wizard navigation
  function nextStep(n){
    document.querySelectorAll('.step').forEach(s=>s.classList.remove('active'));
    document.getElementById('step'+n).classList.add('active');
    if(n===2) startCamera();
    if(n===3) showSnapshot();
    if(n===4) showMeasurements();
  }

  // Distance util
  function dist(a,b){ return Math.sqrt((a.x-b.x)**2+(a.y-b.y)**2+(a.z-b.z)**2); }

  // Measurement calculation
  function calcMeasurements(landmarks){
    const fingers={Thumb:[1,2,3,4],Index:[5,6,7,8],Middle:[9,10,11,12],Ring:[13,14,15,16],Little:[17,18,19,20]};
    let result="# Hand Measurements (mm)\n\n"; let csv="Name,Length_mm\n";

    result+="## Finger lengths\n";
    for(let [name,ids] of Object.entries(fingers)){
      let len=0; for(let i=0;i<ids.length-1;i++) len+=dist(landmarks[ids[i]],landmarks[ids[i+1]]);
      let val=(len*calibrationScale).toFixed(1);
      result+=`- ${name}: ${val} mm\n`; csv+=`${name},${val}\n`;
    }

    result+="\n## Phalanges\n";
    for(let [name,ids] of Object.entries(fingers)){
      for(let i=0;i<ids.length-1;i++){
        let d=dist(landmarks[ids[i]],landmarks[ids[i+1]]);
        let val=(d*calibrationScale).toFixed(1);
        result+=`- ${name} P${i+1}: ${val} mm\n`; csv+=`${name} P${i+1},${val}\n`;
      }
    }

    result+="\n## Knuckles distances\n";
    const mcp=[5,9,13,17];
    for(let i=0;i<mcp.length-1;i++){
      let d=dist(landmarks[mcp[i]],landmarks[mcp[i+1]]);
      let val=(d*calibrationScale).toFixed(1);
      result+=`- MCP${i+1}â€“MCP${i+2}: ${val} mm\n`; csv+=`MCP${i+1}-${i+2},${val}\n`;
    }
    return {md:result,csv};
  }

  function showMeasurements(){ const {md}=calcMeasurements(latestLandmarks); mdBox.textContent=md; }
  function downloadFile(name,type){ const {md,csv}=calcMeasurements(latestLandmarks); let blob=new Blob([type==="md"?md:csv],{type:"text/plain"}); let a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download=name; a.click(); }

  // Camera + Mediapipe
  async function startCamera(){
    try{
      const stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:"environment"}});
      videoElement.srcObject=stream;
      videoElement.play();
      requestAnimationFrame(processFrame);
      drawOverlay();
    }catch(err){ alert("Camera error: "+err); }
  }
  async function processFrame(){
    if(videoElement.readyState===4){ await hands.send({image:videoElement}); }
    requestAnimationFrame(processFrame);
  }

  // Overlay guide
  function drawOverlay(){
    overlayCtx.clearRect(0,0,640,480);
    overlayCtx.strokeStyle="rgba(255,0,0,0.7)";
    overlayCtx.lineWidth=3;
    // Card rectangle (bottom right corner)
    overlayCtx.strokeRect(480,360,140,80);
    overlayCtx.fillStyle="rgba(255,0,0,0.1)";
    overlayCtx.fillRect(480,360,140,80);
    // Simple hand outline (left-center)
    overlayCtx.beginPath();
    overlayCtx.arc(200,250,80,0,2*Math.PI);
    overlayCtx.stroke();
    overlayCtx.fillStyle="rgba(0,0,255,0.1)";
    overlayCtx.fill();
  }

  // Snapshot for calibration
  function showSnapshot(){
    snapshot=canvasElement.toDataURL("image/png");
    let img=new Image();
    img.onload=()=>{calibCtx.drawImage(img,0,0,640,480);};
    img.src=snapshot;
  }
  calibrationCanvas.addEventListener("click",e=>{
    if(calibrationPoints.length<2){
      const rect=calibrationCanvas.getBoundingClientRect();
      calibrationPoints.push({x:(e.clientX-rect.left)/640,y:(e.clientY-rect.top)/480,z:0});
      calibCtx.fillStyle="red"; calibCtx.beginPath(); calibCtx.arc(e.clientX-rect.left,e.clientY-rect.top,5,0,2*Math.PI); calibCtx.fill();
    }
  });
  function finishCalibration(){
    if(calibrationPoints.length===2){
      let pxDist=dist(calibrationPoints[0],calibrationPoints[1]);
      calibrationScale=referenceRealLength/pxDist;
    }
    nextStep(4);
  }

  // Mediapipe Hands
  const hands=new Hands({locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
  hands.setOptions({maxNumHands:1,minDetectionConfidence:0.7,minTrackingConfidence:0.7});
  hands.onResults(results=>{
    canvasCtx.clearRect(0,0,640,480);
    canvasCtx.drawImage(results.image,0,0,640,480);
    if(results.multiHandLandmarks?.length>0){
      latestLandmarks=results.multiHandLandmarks[0];
      drawConnectors(canvasCtx,latestLandmarks,HAND_CONNECTIONS,{color:'#0f0'});
      drawLandmarks(canvasCtx,latestLandmarks,{color:'#f00'});
    }
  });
</script>
</body>
</html>
